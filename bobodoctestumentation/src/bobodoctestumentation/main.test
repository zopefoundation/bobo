bobo main (default) application factory
=======================================

The bobo.main module provides a Paste Deployment application factory
that published module globals that have bobo_response methods. We
call these objects resources.

By default, the main application generated by the factory scans the
given modules for resources.  Let's create some resources in some test modules:

    >>> import bobo, webob, sys
    >>> class Resource:
    ...     def __init__(self, path):
    ...         self.path = path
    ...         self.bobo_order = bobo.order()
    ...     def bobo_response(self, request, path, method):
    ...         print 'trying', self.path
    ...         if path == self.path:
    ...             return self(request)
    ...     def __call__(self, request, where='here'):
    ...         return webob.Response("%s %s!" % (self.path, where))
    ...     def bobo_reroute(self, route):
    ...         return Resource(route)


    >>> import bobo.testmodule1, bobo.testmodule2

    >>> for i in range(5):
    ...     setattr(bobo.testmodule1, 'v%sx' % i, Resource('/mod1/v%s' % i))
    ...     setattr(bobo.testmodule2, 'v%sx' % i, Resource('/mod2/v%s' % i))

Now, we'll create an application:

    >>> import webtest, sys
    >>> stdout = sys.stdout
    >>> def makeapp(*args, **kw):
    ...     app = bobo.Application(*args, **kw)
    ...     def work_around_webtest_duping_stdout(*appargs):
    ...         sys.stdout = stdout
    ...         return app(*appargs)
    ...     return webtest.TestApp(work_around_webtest_duping_stdout)

    >>> app = makeapp(bobo_resources='bobo.testmodule1\nbobo.testmodule2')

We can make requests of the application for our test paths:

    >>> print app.get('/mod1/v0', status=200).body
    trying /mod1/v0
    /mod1/v0 here!

    >>> print app.get('/mod2/v3', status=200).body
    trying /mod1/v0
    trying /mod1/v1
    trying /mod1/v2
    trying /mod1/v3
    trying /mod1/v4
    trying /mod2/v0
    trying /mod2/v1
    trying /mod2/v2
    trying /mod2/v3
    /mod2/v3 here!

If make requests for a path we don't have a resource for, we'll get a
non-found response:

    >>> print app.get('/mod2', status=404).body
    trying /mod1/v0
    trying /mod1/v1
    trying /mod1/v2
    trying /mod1/v3
    trying /mod1/v4
    trying /mod2/v0
    trying /mod2/v1
    trying /mod2/v2
    trying /mod2/v3
    trying /mod2/v4
    <html>
    <head><title>Not Found</title></head>
    <body>Could not find: /mod2</body>
    </html>
    <BLANKLINE>

Route configuration
-------------------

Routes can be defined as part of the configuration:

    >>> app = makeapp(bobo_resources="""
    ...     /foo/bar -> bobo.testmodule1:v2x
    ...     /:where/x ->
    ...          bobo.testmodule1:v3x
    ...     """)

Now, with the new app, the old routes don't work, but the new ones do:

    >>> print app.get('/mod2/v3', status=404).body
    trying /foo/bar
    trying /:where/x
    <html>
    <head><title>Not Found</title></head>
    <body>Could not find: /mod2/v3</body>
    </html>
    <BLANKLINE>

    >>> print app.get('/foo/bar', status=200).body
    trying /foo/bar
    /foo/bar here!

    >>> print app.get('/there/x', status=404).body
    trying /foo/bar
    trying /:where/x
    <html>
    <head><title>Not Found</title></head>
    <body>Could not find: /there/x</body>
    </html>
    <BLANKLINE>

Note that in the last example, we didn't find the resource because our
test resource doesn't interpret route placeholders.

We can have resources that implement subroutes.  That is, they are
called to produce resources.

    >>> class SubRoute:
    ...     def __init__(self, request, **route_info):
    ...         self.route_info = route_info
    ...
    ...     def bobo_response(self, request, path, method):
    ...         if path == '/x/y/z':
    ...             return self(request)
    ...
    ...     def __call__(self, request):
    ...         return webob.Response(str(self.route_info))

    >>> bobo.testmodule2.SubRoute = SubRoute

    >>> app = makeapp(bobo_resources="""
    ...     /:where ->
    ...          bobo.testmodule2:SubRoute
    ...     """)

    >>> print app.get('/there/x', status=404).body
    <html>
    <head><title>Not Found</title></head>
    <body>Could not find: /there/x</body>
    </html>
    <BLANKLINE>

    >>> print app.get('/there/x/y/z', status=200).body
    {'where': u'there'}

Note classes that define bobo_response instance methods aren't
found via module scanning:

    >>> app = makeapp(bobo_resources='bobo.testmodule2')
    >>> print app.get('/xxx', status=404).body
    trying /mod2/v0
    trying /mod2/v1
    trying /mod2/v2
    trying /mod2/v3
    trying /mod2/v4
    <html>
    <head><title>Not Found</title></head>
    <body>Could not find: /xxx</body>
    </html>
    <BLANKLINE>

If the class had been found, calling it's unbound bobo_response
method would have caused an error. OTOH, classes with bobo_response
class methods will be found:

    >>> class C:
    ...     @classmethod
    ...     def bobo_response(self, request, path, method):
    ...         print 'trying C'

    >>> bobo.testmodule2.C = C
    >>> app = makeapp(bobo_resources='bobo.testmodule2')
    >>> print app.get('/xxx', status=404).body
    trying /mod2/v0
    trying /mod2/v1
    trying /mod2/v2
    trying /mod2/v3
    trying /mod2/v4
    trying C
    <html>
    <head><title>Not Found</title></head>
    <body>Could not find: /xxx</body>
    </html>
    <BLANKLINE>

Configuration handlers
----------------------

    >>> import pprint
    >>> def config_handler(d):
    ...     print 'handler1'
    ...     pprint.pprint(d, width=1)

    >>> bobo.testmodule1.config_handler = config_handler

    >>> import pprint
    >>> def config_handler(d):
    ...     print 'handler2'
    ...     pprint.pprint(d, width=1)

    >>> bobo.testmodule2.config_handler = config_handler

    >>> app = makeapp(
    ...     dict(x=1, y=2),
    ...     bobo_resources='bobo.testmodule1',
    ...     bobo_configure=
    ...      'bobo.testmodule2:config_handler bobo.testmodule2:config_handler',
    ...     x=3) # doctest: +NORMALIZE_WHITESPACE
    handler2
    {'bobo_configure':
     'bobo.testmodule2:config_handler bobo.testmodule2:config_handler',
     'bobo_resources': 'bobo.testmodule1',
     'x': 3,
     'y': 2}
    handler2
    {'bobo_configure':
     'bobo.testmodule2:config_handler bobo.testmodule2:config_handler',
     'bobo_resources': 'bobo.testmodule1',
     'x': 3,
     'y': 2}

Scanning modules
----------------

When scanning a module, resources with the same routs are combined.

    >>> bobo.testmodule1.__dict__.clear()

    >>> @bobo.resource('/:y', 'GET')
    ... def gety(request, y):
    ...     return "B.gety %s %s" % (request.method, y)
    >>> @bobo.resource('', 'GET')
    ... def get(request):
    ...     return "B.get %s" % (request.method)
    >>> @bobo.resource('/:y', 'POST')
    ... def posty(request, y):
    ...     return "C.posty %s %s" % (request.method, y)
    >>> @bobo.resource('', 'POST')
    ... def post(request):
    ...     return "C.post %s" % (request.method)

    >>> bobo.testmodule1.get = get
    >>> bobo.testmodule1.gety = gety
    >>> bobo.testmodule1.post = post
    >>> bobo.testmodule1.posty = posty

    >>> app = makeapp(bobo_resources='bobo.testmodule1')

    >>> print app.get('', status=200).body
    B.get GET

    >>> print app.post('', '', status=200).body
    C.post POST

    >>> print app.get('', extra_environ=dict(REQUEST_METHOD='HEAD'),
    ...               status=405)
    Response: 405 Method Not Allowed
    Allow: GET, POST
    Content-Type: text/html; charset=UTF-8
    <BLANKLINE>

    >>> print app.get('/a', status=200).body
    B.gety GET a

    >>> print app.post('/a', '', status=200).body
    C.posty POST a

    >>> print app.delete('/a', status=405)
    Response: 405 Method Not Allowed
    Allow: GET, POST
    Content-Type: text/html; charset=UTF-8
    <html>
    <head><title>Method Not Allowed</title></head>
    <body>Invalid request method: DELETE</body>
    </html>


redirect
--------

    >>> response = bobo.redirect('http://www.python.org/')
    >>> response # doctest: +ELLIPSIS
    <Response at ... 302 Found>

    >>> print str(response).lower()
    302 found
    location: http://www.python.org/
    content-type: text/html; charset=utf-8
    content-length: 26
    <BLANKLINE>
    see http://www.python.org/

    >>> response = bobo.redirect('http://www.python.org/', 301)
    >>> response # doctest: +ELLIPSIS
    <Response at ... 301 Moved Permanently>

Ordering
--------

    >>> l1 = bobo.late()
    >>> l2 = bobo.late()
    >>> o1 = bobo.order()
    >>> o2 = bobo.order()
    >>> e1 = bobo.early()
    >>> e2 = bobo.early()
    >>> e1 < e2 < o1 < o2 < l1 < l2
    True

    >>> bobo.testmodule1.__dict__.clear()

    >>> @bobo.query('/o', order=l1)
    ... def f1():
    ...     return 'f1'
    >>> bobo.testmodule1.f1 = f1

    >>> @bobo.query('/o')
    ... def f2():
    ...     return 'f2'
    >>> bobo.testmodule1.f2 = f2

    >>> app = makeapp(bobo_resources='bobo.testmodule1')
    >>> app.get('/o').body
    'f2'

    >>> @bobo.query('/o', order=bobo.early())
    ... def f3():
    ...     return 'f3'
    >>> bobo.testmodule1.f3 = f3

    >>> app = makeapp(bobo_resources='bobo.testmodule1')
    >>> app.get('/o').body
    'f3'
